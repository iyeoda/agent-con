### App Framework UI Design Overview

1. **Navigation & Active States**
   - Active states are indicated subtly through icon color changes to orange (#D15F36)
   - Text remains in the default slate color (#4C5760) for both active and inactive states
   - No background colors or borders are used for active states
   - Hover states consistently use a light gray background (bg-gray-50) with light gray border (border-gray-200)
   - This pattern is consistent across navigation, settings, and interactive elements
   - Transitions are smooth using transition-all for both background and border changes

2. **Sidebar**
   - A vertical sidebar with icons for "Dashboard," "Data," "AI Agents," and "Settings."
   - Icons are displayed with tooltips that reveal the name of each section when hovered.
   - Sidebar expands on hover to reveal text labels next to the icons.
   - Active state indicated by orange icon color (#D15F36)

3. **Top Bar**
   - Contains the app logo and the active project name ("Woodside").
   - A search button (with an orange icon) opens a modal to handle complex queries.
   - The modal provides a text area for multi-line input and filter options for the search.

4. **Search Modal**
   - Triggered when the search button is clicked.
   - Includes an input field for the search query and options to filter by categories such as Projects, Documents, AI Agents, etc.
   - The modal is styled to match the overall app, with no background dimming.
   - Results are grouped into categories: Documents, Tasks, and Projects, each with links for more details.

5. **Modals & Popovers**
   - Modals use the Radix UI Dialog component for accessibility and consistent behavior.
   - Modals have clean white backgrounds with rounded corners (rounded-lg) and subtle borders (border-[#A7CEBC]).
   - No heavy background dimming to maintain a light, airy feel of the application.
   - Popovers for contextual actions use Radix UI Popover component.
   - Popover content has consistent styling: white background, subtle shadow, border-[#A7CEBC], and rounded corners.
   - All interactive elements within modals and popovers follow the global hover pattern.

6. **Selectors & Dropdown Menus**
   - Dropdown menus use Radix UI primitives for consistent behavior and accessibility
   - Menu triggers and items share consistent hover state (bg-gray-50) with border highlight (border-gray-200)
   - Menu items use rounded corners (rounded-md) and consistent padding (px-3 py-2)
   - Items have transparent borders by default to prevent layout shift on hover
   - Items maintain text color (text-[#4C5760]) for better readability
   - Orange accent color reserved for active/selected states only
   - Minimum width of 12rem ensures content fits comfortably
   - Text wraps naturally to handle longer content using whitespace-normal and break-words
   - Focus states match hover states for keyboard navigation
   - Smooth transitions using transition-all for all interactive states

7. **Command Menu Integration**
   - Command menus (CMDK) are implemented using a combination of Radix UI Dialog and CMDK primitives
   - Selection states use aria-selected attributes instead of data-selected to avoid conflicts
   - Keyboard navigation is handled through CMDK's built-in handlers
   - Styling follows the app's design system while maintaining CMDK's functionality
   - Event handlers use onSelect instead of onClick for better keyboard support
   - Command menu items maintain consistent hover and focus states
   - Dialog overlay uses z-index coordination to prevent conflicts
   - Command menu state is managed independently from other UI components

8. **Calendar Components**
   - **View Types**:
     - Month, Week, and List views with consistent styling and behavior
     - Each view type maintains the same color scheme and interaction patterns
     - Views are responsive and adapt to different screen sizes
     - Current date is highlighted with a subtle background (bg-[#3A366E] bg-opacity-5)
   
   - **Event Display**:
     - Events use color-coded badges based on type:
       - Deadlines: Red (bg-red-100 text-red-800)
       - Milestones: Orange (bg-[#D15F36] bg-opacity-20 text-[#D15F36])
       - Meetings: Blue (bg-blue-100 text-blue-800)
       - Tasks: Mint (bg-[#A7CEBC] bg-opacity-30 text-[#3A366E])
     - Event badges show title and optional time
     - Hover states use opacity changes for subtle interaction
     - Click events open detailed event dialogs
   
   - **Navigation**:
     - Previous/Next buttons for date navigation
     - "Today" button to quickly return to current date
     - View type switcher with active state indication
     - Date range display adapts to current view type
   
   - **Filters**:
     - Multi-select filters for event types, priorities, and assignees
     - Filter badges show active filter count
     - Clear filters option when any filters are active
     - Command-based search for team member selection
   
   - **Event Management**:
     - Add Event dialog with comprehensive form
     - Event Details dialog for viewing and editing
     - Consistent form styling across all dialogs
     - Team member selection with avatar initials
     - Tag management with comma-separated input
   
   - **Responsive Design**:
     - Calendar adapts to different screen sizes
     - Mobile-friendly touch targets
     - Scrollable views for overflow content
     - Maintains readability at all breakpoints

9. **Development & Debugging**
   - Console logging is strictly development-only using environment checks
   - Debug logs are wrapped in a helper function:
     ```typescript
     const debugLog = (...args: any[]) => {
       if (process.env.NODE_ENV === 'development') {
         console.log('[Component Name]:', ...args);
       }
     };
     ```
   - Log messages are prefixed with component name for easy filtering
   - State changes and event handlers include detailed logging
   - Production builds automatically exclude debug logs
   - Debug logs focus on:
     - Component mount/unmount
     - State updates
     - Event handling
     - Data fetching
     - Error conditions
   - Performance monitoring logs are kept separate from debug logs

10. **Styling**
    - The color scheme includes:
      - Indigo (#3A366E) for primary UI elements and emphasis
      - Orange (#D15F36) for active states and key actions
      - Mint (#A7CEBC) for borders and subtle accents
      - Slate (#4C5760) for regular text content
      - Light gray (gray-50) for hover states
      - Light gray (gray-200) for hover borders
    - Text hierarchy:
      - Indigo for headings and emphasis
      - Slate for regular content
      - Consistent text sizes (text-sm for menu items, text-xs for subtle text)
    - Elements are spaced neatly and are responsive
    - Avatars maintain perfect circles using aspect-square and overflow handling
    - Avatar text and images are properly centered and scaled
    - Consistent hover states across all interactive elements
    - Smooth transitions for all interactive states

11. **Component Architecture**
    - **Separation of concerns**: UI components are isolated in dedicated files with specific functionality.
    - **Reusability**: Components like ProjectSelector are designed to be reused across the application with consistent behavior.
    - **Future-proofing**: Components are built with backend integration in mind:
      - API calls can be added inside components
      - Parent components can fetch data and pass as props
      - Loading states and error handling are implemented within components
    - **Maintainability**: Changes to specific functionality (like project selection) are contained to a single file.
    - **Type Safety**: Components use TypeScript interfaces to ensure proper prop usage and data handling.
    - **Accessibility**: 
      - Components leverage Radix UI primitives for keyboard navigation
      - Focus management follows WCAG guidelines
      - Proper ARIA attributes are maintained
      - Interactive elements have appropriate focus indicators
      - Color contrast meets accessibility standards

12. **Data Management & API Integration**
    - **Type System**:
      - Centralized type definitions in `src/types/index.ts`
      - Comprehensive interfaces for all entities (Project, Agent, Person, Company)
      - Strong typing for API requests and responses
      - Type-safe data operations throughout the application
    
    - **Mock Data Organization**:
      - Domain-specific mock data files in `src/mock-data/`
      - Each mock file imports corresponding types
      - Realistic data with proper relationships
      - Consistent structure matching API responses
    
    - **Service Layer**:
      - Base API service with common functionality
      - Domain-specific services for each entity type
      - Consistent error handling and authentication
      - Type-safe API operations
      - Centralized data fetching logic
    
    - **API Integration**:
      - Axios-based API client with interceptors
      - Token-based authentication handling
      - Automatic error handling for unauthorized access
      - Consistent API response structure
      - Environment-based configuration
      - Secure OAuth2 flow implementation for CDE connections
      - Type-safe response handling with generics
    
    - **Authentication & Security**:
      - Secure token storage using AuthService
      - OAuth2 flow for third-party integrations
      - Provider-specific token management
      - Automatic token refresh handling
      - Secure token removal on disconnection
      - Type-safe token operations
    
    - **CDE Connection Management**:
      - Comprehensive CRUD operations for connections
      - Secure OAuth2 flow initiation and callback handling
      - Connection testing and validation
      - Automated data synchronization
      - Provider-specific token management
      - Type-safe connection operations
      - Error handling for invalid connections
    
    - **State Management**:
      - Local state for UI interactions
      - Service-based data fetching
      - Optimistic updates support
      - Error state handling
      - Loading state management
      - Secure token state management
      - Connection state synchronization

13. **Testing Strategy**
    - Components include test scenarios for both mock and real data
    - Error states and loading behaviors are testable
    - Mock data provides consistent test cases
    - Integration tests can swap mock data for API calls
    - E2E tests can use mock data for predictable scenarios
